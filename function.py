# -*- coding: utf-8 -*-
import base64
import collections
import hashlib
import hmac
import logging
import os
import random
import secrets
import time
import tkinter as tk
import urllib.parse
from functools import wraps
from secrets import token_bytes
from tkinter import filedialog
from tkinter import ttk

import cv2 as cv
import pandas as pd
import pymysql
import rsa
import win32api
import win32con
import win32gui
import win32clipboard as clipboard
from Crypto.Cipher import AES
from Crypto.Cipher import DES3
from PIL import ImageGrab
from gmssl import sm2, sm3, sm4, func
from playwright.sync_api import sync_playwright
from pyDes import des, CBC, PAD_PKCS5
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys


def log_info(_text):
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    logger.info(_text)


def log_error(_text, stack_info: bool = True):
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    logger.error(_text, stack_info=stack_info)


js = """
    /*!
     * Note: Auto-generated, do not update manually.
     * Generated by: https://github.com/berstend/puppeteer-extra/tree/master/packages/extract-stealth-evasions
     * Generated on: Sat, 28 Nov 2020 07:21:38 GMT
     * License: MIT
     */
    var opts;
    (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: 'utils => {\n      if (!window.chrome) {\n        // Use the exact property descriptor found in headful Chrome\n        // fetch it via `Object.getOwnPropertyDescriptor(window, \'chrome\')`\n        Object.defineProperty(window, \'chrome\', {\n          writable: true,\n          enumerable: true,\n          configurable: false, // note!\n          value: {} // We\'ll extend that later\n        })\n      }\n\n      // That means we\'re running headful and don\'t need to mock anything\n      if (\'app\' in window.chrome) {\n        return // Nothing to do here\n      }\n\n      const makeError = {\n        ErrorInInvocation: fn => {\n          const err = new TypeError(`Error in invocation of app.${fn}()`)\n          return utils.stripErrorWithAnchor(\n            err,\n            `at ${fn} (eval at <anonymous>`\n          )\n        }\n      }\n\n      // There\'s a some static data in that property which doesn\'t seem to change,\n      // we should periodically check for updates: `JSON.stringify(window.app, null, 2)`\n      const STATIC_DATA = JSON.parse(\n        `\n{\n  "isInstalled": false,\n  "InstallState": {\n    "DISABLED": "disabled",\n    "INSTALLED": "installed",\n    "NOT_INSTALLED": "not_installed"\n  },\n  "RunningState": {\n    "CANNOT_RUN": "cannot_run",\n    "READY_TO_RUN": "ready_to_run",\n    "RUNNING": "running"\n  }\n}\n        `.trim()\n      )\n\n      window.chrome.app = {\n        ...STATIC_DATA,\n\n        get isInstalled() {\n          return false\n        },\n\n        getDetails: function getDetails() {\n          if (arguments.length) {\n            throw makeError.ErrorInInvocation(`getDetails`)\n          }\n          return null\n        },\n        getIsInstalled: function getDetails() {\n          if (arguments.length) {\n            throw makeError.ErrorInInvocation(`getIsInstalled`)\n          }\n          return false\n        },\n        runningState: function getDetails() {\n          if (arguments.length) {\n            throw makeError.ErrorInInvocation(`runningState`)\n          }\n          return \'cannot_run\'\n        }\n      }\n      utils.patchToStringNested(window.chrome.app)\n    }',
        _args: []
    }), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "utils => {\n      if (!window.chrome) {\n        // Use the exact property descriptor found in headful Chrome\n        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\n        Object.defineProperty(window, 'chrome', {\n          writable: true,\n          enumerable: true,\n          configurable: false, // note!\n          value: {} // We'll extend that later\n        })\n      }\n\n      // That means we're running headful and don't need to mock anything\n      if ('csi' in window.chrome) {\n        return // Nothing to do here\n      }\n\n      // Check that the Navigation Timing API v1 is available, we need that\n      if (!window.performance || !window.performance.timing) {\n        return\n      }\n\n      const { timing } = window.performance\n\n      window.chrome.csi = function() {\n        return {\n          onloadT: timing.domContentLoadedEventEnd,\n          startE: timing.navigationStart,\n          pageT: Date.now() - timing.navigationStart,\n          tran: 15 // Transition type or something\n        }\n      }\n      utils.patchToString(window.chrome.csi)\n    }",
        _args: []
    }), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "(utils, { opts }) => {\n        if (!window.chrome) {\n          // Use the exact property descriptor found in headful Chrome\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\n          Object.defineProperty(window, 'chrome', {\n            writable: true,\n            enumerable: true,\n            configurable: false, // note!\n            value: {} // We'll extend that later\n          })\n        }\n\n        // That means we're running headful and don't need to mock anything\n        if ('loadTimes' in window.chrome) {\n          return // Nothing to do here\n        }\n\n        // Check that the Navigation Timing API v1 + v2 is available, we need that\n        if (\n          !window.performance ||\n          !window.performance.timing ||\n          !window.PerformancePaintTiming\n        ) {\n          return\n        }\n\n        const { performance } = window\n\n        // Some stuff is not available on about:blank as it requires a navigation to occur,\n        // let's harden the code to not fail then:\n        const ntEntryFallback = {\n          nextHopProtocol: 'h2',\n          type: 'other'\n        }\n\n        // The API exposes some funky info regarding the connection\n        const protocolInfo = {\n          get connectionInfo() {\n            const ntEntry =\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\n            return ntEntry.nextHopProtocol\n          },\n          get npnNegotiatedProtocol() {\n            // NPN is deprecated in favor of ALPN, but this implementation returns the\n            // HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\n            const ntEntry =\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\n              ? ntEntry.nextHopProtocol\n              : 'unknown'\n          },\n          get navigationType() {\n            const ntEntry =\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\n            return ntEntry.type\n          },\n          get wasAlternateProtocolAvailable() {\n            // The Alternate-Protocol header is deprecated in favor of Alt-Svc\n            // (https://www.mnot.net/blog/2016/03/09/alt-svc), so technically this\n            // should always return false.\n            return false\n          },\n          get wasFetchedViaSpdy() {\n            // SPDY is deprecated in favor of HTTP/2, but this implementation returns\n            // true for HTTP/2 or HTTP2+QUIC/39 as well.\n            const ntEntry =\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\n          },\n          get wasNpnNegotiated() {\n            // NPN is deprecated in favor of ALPN, but this implementation returns true\n            // for HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\n            const ntEntry =\n              performance.getEntriesByType('navigation')[0] || ntEntryFallback\n            return ['h2', 'hq'].includes(ntEntry.nextHopProtocol)\n          }\n        }\n\n        const { timing } = window.performance\n\n        // Truncate number to specific number of decimals, most of the `loadTimes` stuff has 3\n        function toFixed(num, fixed) {\n          var re = new RegExp('^-?\\\\d+(?:.\\\\d{0,' + (fixed || -1) + '})?')\n          return num.toString().match(re)[0]\n        }\n\n        const timingInfo = {\n          get firstPaintAfterLoadTime() {\n            // This was never actually implemented and always returns 0.\n            return 0\n          },\n          get requestTime() {\n            return timing.navigationStart / 1000\n          },\n          get startLoadTime() {\n            return timing.navigationStart / 1000\n          },\n          get commitLoadTime() {\n            return timing.responseStart / 1000\n          },\n          get finishDocumentLoadTime() {\n            return timing.domContentLoadedEventEnd / 1000\n          },\n          get finishLoadTime() {\n            return timing.loadEventEnd / 1000\n          },\n          get firstPaintTime() {\n            const fpEntry = performance.getEntriesByType('paint')[0] || {\n              startTime: timing.loadEventEnd / 1000 // Fallback if no navigation occured (`about:blank`)\n            }\n            return toFixed(\n              (fpEntry.startTime + performance.timeOrigin) / 1000,\n              3\n            )\n          }\n        }\n\n        window.chrome.loadTimes = function() {\n          return {\n            ...protocolInfo,\n            ...timingInfo\n          }\n        }\n        utils.patchToString(window.chrome.loadTimes)\n      }",
        _args: [{opts: {}}]
    }), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "(utils, { opts, STATIC_DATA }) => {\n        if (!window.chrome) {\n          // Use the exact property descriptor found in headful Chrome\n          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`\n          Object.defineProperty(window, 'chrome', {\n            writable: true,\n            enumerable: true,\n            configurable: false, // note!\n            value: {} // We'll extend that later\n          })\n        }\n\n        // That means we're running headful and don't need to mock anything\n        const existsAlready = 'runtime' in window.chrome\n        // `chrome.runtime` is only exposed on secure origins\n        const isNotSecure = !window.location.protocol.startsWith('https')\n        if (existsAlready || (isNotSecure && !opts.runOnInsecureOrigins)) {\n          return // Nothing to do here\n        }\n\n        window.chrome.runtime = {\n          // There's a bunch of static data in that property which doesn't seem to change,\n          // we should periodically check for updates: `JSON.stringify(window.chrome.runtime, null, 2)`\n          ...STATIC_DATA,\n          // `chrome.runtime.id` is extension related and returns undefined in Chrome\n          get id() {\n            return undefined\n          },\n          // These two require more sophisticated mocks\n          connect: null,\n          sendMessage: null\n        }\n\n        const makeCustomRuntimeErrors = (preamble, method, extensionId) => ({\n          NoMatchingSignature: new TypeError(\n            preamble + `No matching signature.`\n          ),\n          MustSpecifyExtensionID: new TypeError(\n            preamble +\n              `${method} called from a webpage must specify an Extension ID (string) for its first argument.`\n          ),\n          InvalidExtensionID: new TypeError(\n            preamble + `Invalid extension id: '${extensionId}'`\n          )\n        })\n\n        // Valid Extension IDs are 32 characters in length and use the letter `a` to `p`:\n        // https://source.chromium.org/chromium/chromium/src/+/master:components/crx_file/id_util.cc;drc=14a055ccb17e8c8d5d437fe080faba4c6f07beac;l=90\n        const isValidExtensionID = str =>\n          str.length === 32 && str.toLowerCase().match(/^[a-p]+$/)\n\n        /** Mock `chrome.runtime.sendMessage` */\n        const sendMessageHandler = {\n          apply: function(target, ctx, args) {\n            const [extensionId, options, responseCallback] = args || []\n\n            // Define custom errors\n            const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `\n            const Errors = makeCustomRuntimeErrors(\n              errorPreamble,\n              `chrome.runtime.sendMessage()`,\n              extensionId\n            )\n\n            // Check if the call signature looks ok\n            const noArguments = args.length === 0\n            const tooManyArguments = args.length > 4\n            const incorrectOptions = options && typeof options !== 'object'\n            const incorrectResponseCallback =\n              responseCallback && typeof responseCallback !== 'function'\n            if (\n              noArguments ||\n              tooManyArguments ||\n              incorrectOptions ||\n              incorrectResponseCallback\n            ) {\n              throw Errors.NoMatchingSignature\n            }\n\n            // At least 2 arguments are required before we even validate the extension ID\n            if (args.length < 2) {\n              throw Errors.MustSpecifyExtensionID\n            }\n\n            // Now let's make sure we got a string as extension ID\n            if (typeof extensionId !== 'string') {\n              throw Errors.NoMatchingSignature\n            }\n\n            if (!isValidExtensionID(extensionId)) {\n              throw Errors.InvalidExtensionID\n            }\n\n            return undefined // Normal behavior\n          }\n        }\n        utils.mockWithProxy(\n          window.chrome.runtime,\n          'sendMessage',\n          function sendMessage() {},\n          sendMessageHandler\n        )\n\n        /**\n         * Mock `chrome.runtime.connect`\n         *\n         * @see https://developer.chrome.com/apps/runtime#method-connect\n         */\n        const connectHandler = {\n          apply: function(target, ctx, args) {\n            const [extensionId, connectInfo] = args || []\n\n            // Define custom errors\n            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `\n            const Errors = makeCustomRuntimeErrors(\n              errorPreamble,\n              `chrome.runtime.connect()`,\n              extensionId\n            )\n\n            // Behavior differs a bit from sendMessage:\n            const noArguments = args.length === 0\n            const emptyStringArgument = args.length === 1 && extensionId === ''\n            if (noArguments || emptyStringArgument) {\n              throw Errors.MustSpecifyExtensionID\n            }\n\n            const tooManyArguments = args.length > 2\n            const incorrectConnectInfoType =\n              connectInfo && typeof connectInfo !== 'object'\n\n            if (tooManyArguments || incorrectConnectInfoType) {\n              throw Errors.NoMatchingSignature\n            }\n\n            const extensionIdIsString = typeof extensionId === 'string'\n            if (extensionIdIsString && extensionId === '') {\n              throw Errors.MustSpecifyExtensionID\n            }\n            if (extensionIdIsString && !isValidExtensionID(extensionId)) {\n              throw Errors.InvalidExtensionID\n            }\n\n            // There's another edge-case here: extensionId is optional so we might find a connectInfo object as first param, which we need to validate\n            const validateConnectInfo = ci => {\n              // More than a first param connectInfo as been provided\n              if (args.length > 1) {\n                throw Errors.NoMatchingSignature\n              }\n              // An empty connectInfo has been provided\n              if (Object.keys(ci).length === 0) {\n                throw Errors.MustSpecifyExtensionID\n              }\n              // Loop over all connectInfo props an check them\n              Object.entries(ci).forEach(([k, v]) => {\n                const isExpected = ['name', 'includeTlsChannelId'].includes(k)\n                if (!isExpected) {\n                  throw new TypeError(\n                    errorPreamble + `Unexpected property: '${k}'.`\n                  )\n                }\n                const MismatchError = (propName, expected, found) =>\n                  TypeError(\n                    errorPreamble +\n                      `Error at property '${propName}': Invalid type: expected ${expected}, found ${found}.`\n                  )\n                if (k === 'name' && typeof v !== 'string') {\n                  throw MismatchError(k, 'string', typeof v)\n                }\n                if (k === 'includeTlsChannelId' && typeof v !== 'boolean') {\n                  throw MismatchError(k, 'boolean', typeof v)\n                }\n              })\n            }\n            if (typeof extensionId === 'object') {\n              validateConnectInfo(extensionId)\n              throw Errors.MustSpecifyExtensionID\n            }\n\n            // Unfortunately even when the connect fails Chrome will return an object with methods we need to mock as well\n            return utils.patchToStringNested(makeConnectResponse())\n          }\n        }\n        utils.mockWithProxy(\n          window.chrome.runtime,\n          'connect',\n          function connect() {},\n          connectHandler\n        )\n\n        function makeConnectResponse() {\n          const onSomething = () => ({\n            addListener: function addListener() {},\n            dispatch: function dispatch() {},\n            hasListener: function hasListener() {},\n            hasListeners: function hasListeners() {\n              return false\n            },\n            removeListener: function removeListener() {}\n          })\n\n          const response = {\n            name: '',\n            sender: undefined,\n            disconnect: function disconnect() {},\n            onDisconnect: onSomething(),\n            onMessage: onSomething(),\n            postMessage: function postMessage() {\n              if (!arguments.length) {\n                throw new TypeError(`Insufficient number of arguments.`)\n              }\n              throw new Error(`Attempting to use a disconnected port object`)\n            }\n          }\n          return response\n        }\n      }",
        _args: [{
            opts: {runOnInsecureOrigins: !1},
            STATIC_DATA: {
                OnInstalledReason: {
                    CHROME_UPDATE: "chrome_update",
                    INSTALL: "install",
                    SHARED_MODULE_UPDATE: "shared_module_update",
                    UPDATE: "update"
                },
                OnRestartRequiredReason: {APP_UPDATE: "app_update", OS_UPDATE: "os_update", PERIODIC: "periodic"},
                PlatformArch: {
                    ARM: "arm",
                    ARM64: "arm64",
                    MIPS: "mips",
                    MIPS64: "mips64",
                    X86_32: "x86-32",
                    X86_64: "x86-64"
                },
                PlatformNaclArch: {ARM: "arm", MIPS: "mips", MIPS64: "mips64", X86_32: "x86-32", X86_64: "x86-64"},
                PlatformOs: {ANDROID: "android", CROS: "cros", LINUX: "linux", MAC: "mac", OPENBSD: "openbsd", WIN: "win"},
                RequestUpdateCheckStatus: {
                    NO_UPDATE: "no_update",
                    THROTTLED: "throttled",
                    UPDATE_AVAILABLE: "update_available"
                }
            }
        }]
    }), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "utils => {\n      /**\n       * Input might look funky, we need to normalize it so e.g. whitespace isn't an issue for our spoofing.\n       *\n       * @example\n       * video/webm; codecs=\"vp8, vorbis\"\n       * video/mp4; codecs=\"avc1.42E01E\"\n       * audio/x-m4a;\n       * audio/ogg; codecs=\"vorbis\"\n       * @param {String} arg\n       */\n      const parseInput = arg => {\n        const [mime, codecStr] = arg.trim().split(';')\n        let codecs = []\n        if (codecStr && codecStr.includes('codecs=\"')) {\n          codecs = codecStr\n            .trim()\n            .replace(`codecs=\"`, '')\n            .replace(`\"`, '')\n            .trim()\n            .split(',')\n            .filter(x => !!x)\n            .map(x => x.trim())\n        }\n        return {\n          mime,\n          codecStr,\n          codecs\n        }\n      }\n\n      const canPlayType = {\n        // Intercept certain requests\n        apply: function(target, ctx, args) {\n          if (!args || !args.length) {\n            return target.apply(ctx, args)\n          }\n          const { mime, codecs } = parseInput(args[0])\n          // This specific mp4 codec is missing in Chromium\n          if (mime === 'video/mp4') {\n            if (codecs.includes('avc1.42E01E')) {\n              return 'probably'\n            }\n          }\n          // This mimetype is only supported if no codecs are specified\n          if (mime === 'audio/x-m4a' && !codecs.length) {\n            return 'maybe'\n          }\n\n          // This mimetype is only supported if no codecs are specified\n          if (mime === 'audio/aac' && !codecs.length) {\n            return 'probably'\n          }\n          // Everything else as usual\n          return target.apply(ctx, args)\n        }\n      }\n\n      /* global HTMLMediaElement */\n      utils.replaceWithProxy(\n        HTMLMediaElement.prototype,\n        'canPlayType',\n        canPlayType\n      )\n    }",
        _args: []
    }), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "(utils, opts) => {\n      const patchNavigator = (name, value) =>\n        utils.replaceProperty(Object.getPrototypeOf(navigator), name, {\n          get() {\n            return value\n          }\n        })\n\n      patchNavigator('hardwareConcurrency', opts.hardwareConcurrency || 4)\n    }",
        _args: [{}]
    }), opts = {}, Object.defineProperty(Object.getPrototypeOf(navigator), "languages", {get: () => opts.languages || ["en-US", "en"]}), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "(utils, opts) => {\n      const handler = {\n        apply: function(target, ctx, args) {\n          const param = (args || [])[0]\n\n          if (param && param.name && param.name === 'notifications') {\n            const result = { state: Notification.permission }\n            Object.setPrototypeOf(result, PermissionStatus.prototype)\n            return Promise.resolve(result)\n          }\n\n          return utils.cache.Reflect.apply(...arguments)\n        }\n      }\n\n      utils.replaceWithProxy(\n        window.navigator.permissions.__proto__, // eslint-disable-line no-proto\n        'query',\n        handler\n      )\n    }",
        _args: [{}]
    }), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "(utils, { fns, data }) => {\n        fns = utils.materializeFns(fns)\n\n        // That means we're running headful\n        const hasPlugins = 'plugins' in navigator && navigator.plugins.length\n        if (hasPlugins) {\n          return // nothing to do here\n        }\n\n        const mimeTypes = fns.generateMimeTypeArray(utils, fns)(data.mimeTypes)\n        const plugins = fns.generatePluginArray(utils, fns)(data.plugins)\n\n        // Plugin and MimeType cross-reference each other, let's do that now\n        // Note: We're looping through `data.plugins` here, not the generated `plugins`\n        for (const pluginData of data.plugins) {\n          pluginData.__mimeTypes.forEach((type, index) => {\n            plugins[pluginData.name][index] = mimeTypes[type]\n\n            Object.defineProperty(plugins[pluginData.name], type, {\n              value: mimeTypes[type],\n              writable: false,\n              enumerable: false, // Not enumerable\n              configurable: true\n            })\n            Object.defineProperty(mimeTypes[type], 'enabledPlugin', {\n              value: new Proxy(plugins[pluginData.name], {}), // Prevent circular references\n              writable: false,\n              enumerable: false, // Important: `JSON.stringify(navigator.plugins)`\n              configurable: true\n            })\n          })\n        }\n\n        const patchNavigator = (name, value) =>\n          utils.replaceProperty(Object.getPrototypeOf(navigator), name, {\n            get() {\n              return value\n            }\n          })\n\n        patchNavigator('mimeTypes', mimeTypes)\n        patchNavigator('plugins', plugins)\n\n        // All done\n      }",
        _args: [{
            fns: {
                generateMimeTypeArray: "(utils, fns) => mimeTypesData => {\n  return fns.generateMagicArray(utils, fns)(\n    mimeTypesData,\n    MimeTypeArray.prototype,\n    MimeType.prototype,\n    'type'\n  )\n}",
                generatePluginArray: "(utils, fns) => pluginsData => {\n  return fns.generateMagicArray(utils, fns)(\n    pluginsData,\n    PluginArray.prototype,\n    Plugin.prototype,\n    'name'\n  )\n}",
                generateMagicArray: "(utils, fns) =>\n  function(\n    dataArray = [],\n    proto = MimeTypeArray.prototype,\n    itemProto = MimeType.prototype,\n    itemMainProp = 'type'\n  ) {\n    // Quick helper to set props with the same descriptors vanilla is using\n    const defineProp = (obj, prop, value) =>\n      Object.defineProperty(obj, prop, {\n        value,\n        writable: false,\n        enumerable: false, // Important for mimeTypes & plugins: `JSON.stringify(navigator.mimeTypes)`\n        configurable: true\n      })\n\n    // Loop over our fake data and construct items\n    const makeItem = data => {\n      const item = {}\n      for (const prop of Object.keys(data)) {\n        if (prop.startsWith('__')) {\n          continue\n        }\n        defineProp(item, prop, data[prop])\n      }\n      return patchItem(item, data)\n    }\n\n    const patchItem = (item, data) => {\n      let descriptor = Object.getOwnPropertyDescriptors(item)\n\n      // Special case: Plugins have a magic length property which is not enumerable\n      // e.g. `navigator.plugins[i].length` should always be the length of the assigned mimeTypes\n      if (itemProto === Plugin.prototype) {\n        descriptor = {\n          ...descriptor,\n          length: {\n            value: data.__mimeTypes.length,\n            writable: false,\n            enumerable: false,\n            configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\n          }\n        }\n      }\n\n      // We need to spoof a specific `MimeType` or `Plugin` object\n      const obj = Object.create(itemProto, descriptor)\n\n      // Virtually all property keys are not enumerable in vanilla\n      const blacklist = [...Object.keys(data), 'length', 'enabledPlugin']\n      return new Proxy(obj, {\n        ownKeys(target) {\n          return Reflect.ownKeys(target).filter(k => !blacklist.includes(k))\n        },\n        getOwnPropertyDescriptor(target, prop) {\n          if (blacklist.includes(prop)) {\n            return undefined\n          }\n          return Reflect.getOwnPropertyDescriptor(target, prop)\n        }\n      })\n    }\n\n    const magicArray = []\n\n    // Loop through our fake data and use that to create convincing entities\n    dataArray.forEach(data => {\n      magicArray.push(makeItem(data))\n    })\n\n    // Add direct property access  based on types (e.g. `obj['application/pdf']`) afterwards\n    magicArray.forEach(entry => {\n      defineProp(magicArray, entry[itemMainProp], entry)\n    })\n\n    // This is the best way to fake the type to make sure this is false: `Array.isArray(navigator.mimeTypes)`\n    const magicArrayObj = Object.create(proto, {\n      ...Object.getOwnPropertyDescriptors(magicArray),\n\n      // There's one ugly quirk we unfortunately need to take care of:\n      // The `MimeTypeArray` prototype has an enumerable `length` property,\n      // but headful Chrome will still skip it when running `Object.getOwnPropertyNames(navigator.mimeTypes)`.\n      // To strip it we need to make it first `configurable` and can then overlay a Proxy with an `ownKeys` trap.\n      length: {\n        value: magicArray.length,\n        writable: false,\n        enumerable: false,\n        configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\n      }\n    })\n\n    // Generate our functional function mocks :-)\n    const functionMocks = fns.generateFunctionMocks(utils)(\n      proto,\n      itemMainProp,\n      magicArray\n    )\n\n    // We need to overlay our custom object with a JS Proxy\n    const magicArrayObjProxy = new Proxy(magicArrayObj, {\n      get(target, key = '') {\n        // Redirect function calls to our custom proxied versions mocking the vanilla behavior\n        if (key === 'item') {\n          return functionMocks.item\n        }\n        if (key === 'namedItem') {\n          return functionMocks.namedItem\n        }\n        if (proto === PluginArray.prototype && key === 'refresh') {\n          return functionMocks.refresh\n        }\n        // Everything else can pass through as normal\n        return utils.cache.Reflect.get(...arguments)\n      },\n      ownKeys(target) {\n        // There are a couple of quirks where the original property demonstrates \"magical\" behavior that makes no sense\n        // This can be witnessed when calling `Object.getOwnPropertyNames(navigator.mimeTypes)` and the absense of `length`\n        // My guess is that it has to do with the recent change of not allowing data enumeration and this being implemented weirdly\n        // For that reason we just completely fake the available property names based on our data to match what regular Chrome is doing\n        // Specific issues when not patching this: `length` property is available, direct `types` props (e.g. `obj['application/pdf']`) are missing\n        const keys = []\n        const typeProps = magicArray.map(mt => mt[itemMainProp])\n        typeProps.forEach((_, i) => keys.push(`${i}`))\n        typeProps.forEach(propName => keys.push(propName))\n        return keys\n      },\n      getOwnPropertyDescriptor(target, prop) {\n        if (prop === 'length') {\n          return undefined\n        }\n        return Reflect.getOwnPropertyDescriptor(target, prop)\n      }\n    })\n\n    return magicArrayObjProxy\n  }",
                generateFunctionMocks: "utils => (\n  proto,\n  itemMainProp,\n  dataArray\n) => ({\n  /** Returns the MimeType object with the specified index. */\n  item: utils.createProxy(proto.item, {\n    apply(target, ctx, args) {\n      if (!args.length) {\n        throw new TypeError(\n          `Failed to execute 'item' on '${\n            proto[Symbol.toStringTag]\n          }': 1 argument required, but only 0 present.`\n        )\n      }\n      // Special behavior alert:\n      // - Vanilla tries to cast strings to Numbers (only integers!) and use them as property index lookup\n      // - If anything else than an integer (including as string) is provided it will return the first entry\n      const isInteger = args[0] && Number.isInteger(Number(args[0])) // Cast potential string to number first, then check for integer\n      // Note: Vanilla never returns `undefined`\n      return (isInteger ? dataArray[Number(args[0])] : dataArray[0]) || null\n    }\n  }),\n  /** Returns the MimeType object with the specified name. */\n  namedItem: utils.createProxy(proto.namedItem, {\n    apply(target, ctx, args) {\n      if (!args.length) {\n        throw new TypeError(\n          `Failed to execute 'namedItem' on '${\n            proto[Symbol.toStringTag]\n          }': 1 argument required, but only 0 present.`\n        )\n      }\n      return dataArray.find(mt => mt[itemMainProp] === args[0]) || null // Not `undefined`!\n    }\n  }),\n  /** Does nothing and shall return nothing */\n  refresh: proto.refresh\n    ? utils.createProxy(proto.refresh, {\n        apply(target, ctx, args) {\n          return undefined\n        }\n      })\n    : undefined\n})"
            },
            data: {
                mimeTypes: [{
                    type: "application/pdf",
                    suffixes: "pdf",
                    description: "",
                    __pluginName: "Chrome PDF Viewer"
                }, {
                    type: "application/x-google-chrome-pdf",
                    suffixes: "pdf",
                    description: "Portable Document Format",
                    __pluginName: "Chrome PDF Plugin"
                }, {
                    type: "application/x-nacl",
                    suffixes: "",
                    description: "Native Client Executable",
                    __pluginName: "Native Client"
                }, {
                    type: "application/x-pnacl",
                    suffixes: "",
                    description: "Portable Native Client Executable",
                    __pluginName: "Native Client"
                }],
                plugins: [{
                    name: "Chrome PDF Plugin",
                    filename: "internal-pdf-viewer",
                    description: "Portable Document Format",
                    __mimeTypes: ["application/x-google-chrome-pdf"]
                }, {
                    name: "Chrome PDF Viewer",
                    filename: "mhjfbmdgcfjbbpaeojofohoefgiehjai",
                    description: "",
                    __mimeTypes: ["application/pdf"]
                }, {
                    name: "Native Client",
                    filename: "internal-nacl-plugin",
                    description: "",
                    __mimeTypes: ["application/x-nacl", "application/x-pnacl"]
                }]
            }
        }]
    }), delete Object.getPrototypeOf(navigator).webdriver, (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "(utils, opts) => {\n      const getParameterProxyHandler = {\n        apply: function(target, ctx, args) {\n          const param = (args || [])[0]\n          // UNMASKED_VENDOR_WEBGL\n          if (param === 37445) {\n            return opts.vendor || 'Intel Inc.' // default in headless: Google Inc.\n          }\n          // UNMASKED_RENDERER_WEBGL\n          if (param === 37446) {\n            return opts.renderer || 'Intel Iris OpenGL Engine' // default in headless: Google SwiftShader\n          }\n          return utils.cache.Reflect.apply(target, ctx, args)\n        }\n      }\n\n      // There's more than one WebGL rendering context\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Browser_compatibility\n      // To find out the original values here: Object.getOwnPropertyDescriptors(WebGLRenderingContext.prototype.getParameter)\n      const addProxy = (obj, propName) => {\n        utils.replaceWithProxy(obj, propName, getParameterProxyHandler)\n      }\n      // For whatever weird reason loops don't play nice with Object.defineProperty, here's the next best thing:\n      addProxy(WebGLRenderingContext.prototype, 'getParameter')\n      addProxy(WebGL2RenderingContext.prototype, 'getParameter')\n    }",
        _args: [{}]
    }), (() => {
        try {
            if (window.outerWidth && window.outerHeight) return;
            const n = 85;
            window.outerWidth = window.innerWidth, window.outerHeight = window.innerHeight + n
        } catch (n) {
        }
    })(), (({_utilsFns: _utilsFns, _mainFunction: _mainFunction, _args: _args}) => {
        const utils = Object.fromEntries(Object.entries(_utilsFns).map((([key, value]) => [key, eval(value)])));
        utils.preloadCache(), eval(_mainFunction)(utils, ..._args)
    })({
        _utilsFns: {
            stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {}\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function() {\n      try {\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \"anchor\" line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = stack => {\n          const blacklist = [\n            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply\n            `at Object.${trap} `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.<computed> [as ${trap}] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split('\\n')\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) => index !== 1)\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n\n        const stripWithAnchor = stack => {\n          const stackArr = stack.split('\\n')\n          const anchor = `at Object.newHandler.<computed> [as ${trap}] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false // 404, anchor not found\n          }\n          // Strip everything from the top until we reach the anchor line\n          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      }\n    }\n  })\n  return newHandler\n}",
            stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err // 404, anchor not found\n  }\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
            replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  })\n}",
            preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    // Used in our proxies\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + '' // => `function toString() { [native code] }`\n  }\n}",
            makeNativeString: "(name = '') => {\n  // Cache (per-window) the original native toString or use that if available\n  utils.preloadCache()\n  return utils.cache.nativeToStringStr.replace('toString', name || '')\n}",
            patchToString: "(obj, str = '') => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) {\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      }\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
            redirectToString: "(proxyObj, originalObj) => {\n  utils.preloadCache()\n\n  const toStringProxy = new Proxy(Function.prototype.toString, {\n    apply: function(target, ctx) {\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \"\"`\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + '' || fallback()\n      }\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) {\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      }\n\n      return target.call(ctx)\n    }\n  })\n  utils.replaceProperty(Function.prototype, 'toString', {\n    value: toStringProxy\n  })\n}",
            replaceWithProxy: "(obj, propName, handler) => {\n  utils.preloadCache()\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n}",
            mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, { value: proxyObj })\n  utils.patchToString(proxyObj)\n\n  return true\n}",
            createProxy: "(pseudoTarget, handler) => {\n  utils.preloadCache()\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n}",
            splitObjPath: "objPath => ({\n  // Remove last dot entry (property) ==> `HTMLMediaElement.prototype`\n  objName: objPath\n    .split('.')\n    .slice(0, -1)\n    .join('.'),\n  // Extract last dot entry ==> `canPlayType`\n  propName: objPath.split('.').slice(-1)[0]\n})",
            replaceObjPathWithProxy: "(objPath, handler) => {\n  const { objName, propName } = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n}",
            execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      if (obj[key] === undefined) {\n        continue\n      }\n      if (obj[key] && typeof obj[key] === 'object') {\n        recurse(obj[key])\n      } else {\n        if (obj[key] && typeFilter.includes(typeof obj[key])) {\n          fn.call(this, obj[key])\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return obj\n}",
            stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) // eslint-disable-line no-eval\n  )\n}",
            materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      if (value.startsWith('function')) {\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() => ${value}`)()] // eslint-disable-line no-eval\n      } else {\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      }\n    })\n  )\n}"
        },
        _mainFunction: "(utils, opts) => {\n      try {\n        // Adds a contentWindow proxy to the provided iframe element\n        const addContentWindowProxy = iframe => {\n          const contentWindowProxy = {\n            get(target, key) {\n              // Now to the interesting part:\n              // We actually make this thing behave like a regular iframe window,\n              // by intercepting calls to e.g. `.self` and redirect it to the correct thing. :)\n              // That makes it possible for these assertions to be correct:\n              // iframe.contentWindow.self === window.top // must be false\n              if (key === 'self') {\n                return this\n              }\n              // iframe.contentWindow.frameElement === iframe // must be true\n              if (key === 'frameElement') {\n                return iframe\n              }\n              return Reflect.get(target, key)\n            }\n          }\n\n          if (!iframe.contentWindow) {\n            const proxy = new Proxy(window, contentWindowProxy)\n            Object.defineProperty(iframe, 'contentWindow', {\n              get() {\n                return proxy\n              },\n              set(newValue) {\n                return newValue // contentWindow is immutable\n              },\n              enumerable: true,\n              configurable: false\n            })\n          }\n        }\n\n        // Handles iframe element creation, augments `srcdoc` property so we can intercept further\n        const handleIframeCreation = (target, thisArg, args) => {\n          const iframe = target.apply(thisArg, args)\n\n          // We need to keep the originals around\n          const _iframe = iframe\n          const _srcdoc = _iframe.srcdoc\n\n          // Add hook for the srcdoc property\n          // We need to be very surgical here to not break other iframes by accident\n          Object.defineProperty(iframe, 'srcdoc', {\n            configurable: true, // Important, so we can reset this later\n            get: function() {\n              return _iframe.srcdoc\n            },\n            set: function(newValue) {\n              addContentWindowProxy(this)\n              // Reset property, the hook is only needed once\n              Object.defineProperty(iframe, 'srcdoc', {\n                configurable: false,\n                writable: false,\n                value: _srcdoc\n              })\n              _iframe.srcdoc = newValue\n            }\n          })\n          return iframe\n        }\n\n        // Adds a hook to intercept iframe creation events\n        const addIframeCreationSniffer = () => {\n          /* global document */\n          const createElementHandler = {\n            // Make toString() native\n            get(target, key) {\n              return Reflect.get(target, key)\n            },\n            apply: function(target, thisArg, args) {\n              const isIframe =\n                args && args.length && `${args[0]}`.toLowerCase() === 'iframe'\n              if (!isIframe) {\n                // Everything as usual\n                return target.apply(thisArg, args)\n              } else {\n                return handleIframeCreation(target, thisArg, args)\n              }\n            }\n          }\n          // All this just due to iframes with srcdoc bug\n          utils.replaceWithProxy(\n            document,\n            'createElement',\n            createElementHandler\n          )\n        }\n\n        // Let's go\n        addIframeCreationSniffer()\n      } catch (err) {\n        // console.warn(err)\n      }\n    }",
        _args: []
    });
    """


# selenium方法
class AC(object):
    def __init__(self, **kwargs):
        _option = kwargs.get("_option", None)
        if not _option:
            _option = webdriver.ChromeOptions()
            _pre_fs = dict()
            _pre_fs["credentials_enable_service"] = False
            _pre_fs["profile.password_manager_enabled"] = False
            if kwargs.get('download_path', False):
                _pre_fs['profile.default_content_settings.popups'] = 0
                _pre_fs['download.default_directory'] = kwargs['download_path']
                _pre_fs['profile.default_content_setting_values.automatic_downloads'] = 1
            else:
                # 下载前询问每个文件的保存位置   True是开启，False是关闭 ,与chrome_down_path搭配使用
                _pre_fs["download.prompt_for_download"] = True
            _option.add_experimental_option("prefs", _pre_fs)  # 关掉是否记住密码弹窗
            if proxy := kwargs.get("proxy", None):
                _option.add_argument('--proxy-server=%s' % proxy)
            if kwargs.get("_headless", False):
                logging.info("开启无头")
                # 无头模式
                _option.add_argument('--headless')
            if kwargs.get("incognito", None):
                _option.add_argument('--incognito')  # 无痕模式
            _option.add_experimental_option('useAutomationExtension', False)  # 关闭“chrome正受到自动测试软件的控制”
            _option.add_experimental_option("excludeSwitches", ['enable-automation'])
            _option.add_argument("--disable-blink-features=AutomationControlled")
            _option.add_experimental_option("detach", True)  # 不自动关闭浏览器
            _option.add_argument('--disable-gpu')  # 禁用GPU加速
            _option.add_argument("disable-web-security")  # 允许谷歌浏览器重定向网址
            # cookie 新特性 禁用可以支持跨域访问
            _option.add_argument('--disable-features=SameSiteByDefaultCookies,CookiesWithoutSameSiteMustBeSecure')
            _option.add_argument('-–no-sandbox')
            if user_data := kwargs.get("user_data", None):
                _option.add_argument(f'user-data-dir={user_data}')
            if binary_location := kwargs.get("binary_location", None):
                _option.binary_location = binary_location
        self.driver = webdriver.Chrome(options=_option, executable_path=kwargs.get("exec_path", "chromedriver"))
        self.driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {"source": js})
        if kwargs.get("max_size", True):
            self.driver.maximize_window()

    def close_other_labels(self, label_handle: str or list, switch_to=None):
        """
        selenium关闭其他页面方法
        :param label_handle: 需要保留的页面title名称
        :param switch_to:
        """
        if isinstance(label_handle, str):
            label_handle = [label_handle]
        retain_handle = collections.OrderedDict()
        while True:
            handle: list = self.driver.window_handles
            for i in handle:
                self.driver.switch_to.window(i)
                if self.driver.title in label_handle:
                    retain_handle[self.driver.title] = i
                    continue
                elif i in label_handle:
                    retain_handle[i] = i
                    continue
                self.driver.close()
            if len(retain_handle) == len(label_handle):
                break
        self.driver.switch_to.window(
            [i for i in retain_handle.values()][0] if not switch_to else retain_handle[switch_to])

    # 查找alert弹窗
    def alert_win(self, wait_time=30, is_disable=0):
        """
        查找alert弹窗
        :param wait_time:
        :param is_disable: is_disable=0 直接返回这个alert、 is_disable=1 点击alert的确定、is_disable=2 点击alert的取消
        """
        all_time = time.time() + wait_time
        while time.time() <= all_time:
            try:
                if is_disable == 0:
                    return self.driver.switch_to.alert
                if is_disable == 1:
                    self.driver.switch_to.alert.accept()
                elif is_disable == 2:
                    self.driver.switch_to.alert.dismiss()
            except:
                ...
        return False

    # 双击元素
    def double_click(self, xpath, wait_time=30):
        log_info(xpath)
        el = self.wait_time_click(xpath, wait_time, style=3)
        ActionChains(self.driver).double_click(el).perform()

    # selenium点击方法
    def wait_time_click(self, xpath, wait_time=30, style: int = 1):
        """
        selenium点击方法
        :param xpath: 不用多说
        :param wait_time: 等待时间
        :param style: 默认为1，查找元素并点击，数值为2数值为按查找元素并等待成功True失败False，数值为3则正常查找并返回当前元素
        :return:
        """

        log_info(xpath)
        all_time = time.time() + wait_time
        if style == 1:
            while time.time() <= all_time:
                try:
                    el = self.driver.find_element(By.XPATH, xpath)
                    if el.is_displayed() and el.is_enabled():
                        return el.click()
                except:
                    ...
            raise Exception("operate timeout")
        elif style == 2:
            while time.time() <= all_time:
                try:
                    el = self.driver.find_element(By.XPATH, xpath)
                    if el.is_displayed() and el.is_enabled():
                        return True
                except:
                    ...
            return False
        else:
            while time.time() <= all_time:
                try:
                    el = self.driver.find_element(By.XPATH, xpath)
                    if el.is_displayed() and el.is_enabled():
                        return el
                except:
                    ...
            raise Exception("元素查找超时！！！")

    # 滑块仅限于一次滑到头的
    def slider_verification(self, slider_xpath, slider_bar_xpath, acceleration=None):
        """
        滑块仅限于一次滑到头的
        :param slider_xpath: 滑块的xpath
        :param slider_bar_xpath: 滑动条Xpath
        :param acceleration:  速度调节 [min, max] 随机从其中取值 作为速度 默认[500, 800]
        """
        if acceleration is None:
            acceleration = [500, 800]
        acceleration = random.randint(acceleration[0], acceleration[1])

        def get_move_track(gap):
            """用来计算移动速度"""
            # 移动轨迹
            _track = []
            # 当前位移
            current = 0
            # 减速阈值
            mid = gap * 4 / 5  # 前4/5段加速 后1/5段减速
            t = 0.2  # 计算间隔
            v = 0  # 初速度
            while current < gap:
                if current < mid:
                    a = acceleration
                else:
                    a = -acceleration
                v0 = v  # 初速度v0
                v = v0 + a * t  # 当前速度
                move = v0 * t + 1 / 2 * a * t * t  # 移动距离
                current += move  # 当前位移
                _track.append(round(move))  # 加入轨迹
            return _track

        # 滑块的宽
        move_back_width = self.driver.execute_script("return arguments[0].clientWidth",
                                                self.driver.find_element(By.XPATH, slider_xpath))
        # 滑条的宽
        slide_bar_width = self.driver.execute_script("return arguments[0].clientWidth",
                                                self.driver.find_element(By.XPATH, slider_bar_xpath))
        # 滑条剩余的长度
        slide_length = slide_bar_width - move_back_width
        track = get_move_track(slide_length)
        ActionChains(self.driver).click_and_hold(
            self.driver.find_element(By.XPATH, slider_xpath)).perform()
        for x in track:
            ActionChains(self.driver).move_by_offset(xoffset=x, yoffset=0).perform()
        # 滑动结束后随机停顿
        time.sleep(random.random())
        # 松开鼠标
        ActionChains(self.driver).release().perform()

    # selenium清除数据并输入
    def clear_and_enter(self, xpath, text, is_keyboard: bool = False):
        """
        selenium清除数据并输入
        :param xpath:
        :param text: 需要输入的内容
        :param is_keyboard: 是否使用键盘清除数据
        :return:
        """
        el = self.wait_time_click(xpath, style=3)
        if is_keyboard is False:
            el.clear()
            time.sleep(0.5)
        else:
            el.send_keys(Keys.CONTROL + 'a')
            time.sleep(0.5)
            el.send_keys(Keys.DELETE)
        el.send_keys(text)

    # 切换页面title
    def switch_to_title(self, title, max_size: bool = True, wait_time=15, handle_len: int = 0):
        """
        切换页面title
        :param title: 要切换的title名称
        :param max_size: 是否需要页面最大化
        :param wait_time:
        :param handle_len:
        """
        all_time = time.time()
        while (time.time() - all_time) < wait_time:
            all_handle = self.driver.window_handles
            if handle_len:
                if len(all_handle) != handle_len:
                    continue
            for h in all_handle:
                self.driver.switch_to.window(h)
                if self.driver.title == title:
                    if max_size:
                        self.driver.maximize_window()
                    return True  # 用来跳出双层循环
        raise Exception(f"Switch to window[{title}] timeout")

    # 切入iframe
    def cut_in_frame(self, xpath: list):
        for iframe in xpath:
            self.wait_time_click(xpath=iframe, style=3)
            self.driver.switch_to.frame(iframe)
            time.sleep(0.8)

    # 判断元素是否消失
    def element_not_exist(self, xpath, wait_time=30):
        all_time = time.time() + wait_time
        while time.time() <= all_time:
            try:
                el = self.driver.find_element(By.XPATH, xpath)
                if el.is_displayed() and el.is_enabled():
                    continue
                else:
                    return True
            except:
                ...
        raise Exception("operate timeout")

    # 获取所有子元素
    def get_elements(self, xpath, wait_time=30):
        self.wait_page_load()
        all_time = time.time() + wait_time
        while time.time() <= all_time:
            try:
                el = self.driver.find_elements(By.XPATH, xpath)
                return el
            except:
                ...
        raise Exception("operate timeout!!!")

    # 控制鼠标移动到指定元素
    def slide_mouse(self, xpath, is_click=True):
        """
        控制鼠标移动到指定元素
        :param xpath:
        :param is_click: 是否需要点击
        """
        target_element = self.wait_time_click(xpath, style=3)
        actions = ActionChains(self.driver)
        # 移动鼠标到目标元素
        actions.move_to_element(target_element).perform()
        if is_click:
            actions.click(target_element).perform()
        return

    # 使用js使页面下滑到指定元素位置
    def slide_xpath(self, xpath, wait_time=30, direction=False):
        """
        使用js使页面下滑到指定元素位置
        :param xpath:
        :param wait_time:
        :param direction: True向上滑动，False向下滑动
        """
        all_time = time.time() + wait_time
        while time.time() <= all_time:
            try:
                el = self.driver.find_element(By.XPATH, xpath)
                if direction is False:
                    self.driver.execute_script(f"arguments[0].scrollIntoView(false);", el)
                else:
                    self.driver.execute_script(f"arguments[0].scrollIntoView(ture);", el)
                return
            except Exception:
                ...
        raise Exception("operate timeout")

    # 判断xpath中对应的元素是否存在
    def elements_value(self, xpath, element_key: str, element_value: str, wait_time=30):
        """
        判断xpath中对应的元素是否存在
        :param xpath:
        :param wait_time
        :param element_key: 获取的元素类型（class, id, name ......）
        :param element_value: 需要判断是否存在的内容
        """
        el = self.wait_time_click(xpath, wait_time, style=3)
        _text = el.get_attribute(element_key)
        if element_value in _text:
            return True
        return False

    # 切入上级iframe
    def superior_iframe(self, hierarchy: int):
        """
        切入上级iframe
        :param hierarchy: 切出iframe的层数
        """
        for i in range(hierarchy):
            self.driver.switch_to.parent_frame()
            time.sleep(0.5)

    # 等待页面是否加载完成
    def wait_page_load(self):
        initial_time = time.time()
        while (time.time() - initial_time) < 30:
            if self.driver.execute_script("return document.readyState") == "complete":
                log_info("完成！")
                return
            log_info("未完成！")
        raise Exception("页面加载超时")

    # 调用js方法
    def js_function(self, xpath, js_fun):
        """
        调用js方法
        :param xpath:
        :param js_fun: 需要的方法
        """
        fun = self.wait_time_click(xpath, style=3)
        self.driver.execute_script(js_fun, fun)

    # 使用js方法填写数据
    def js_input(self, xpath, value):
        """
        使用js方法填写数据
        :param xpath:
        :param value: 要输入的文本
        """
        fun = self.wait_time_click(xpath, style=3)
        self.driver.execute_script(f"arguments[0].value='{value}';", fun)

    # selenium 新开页面并跳转到该页面
    def open_new_page(self, url):
        """
        selenium 新开页面并跳转到该页面
        :param url: 新开页面的地址
        """
        self.driver.execute_script(f"window.open('{url}');")
        all_windows = self.driver.window_handles
        self.driver.switch_to.window(all_windows[-1])

    # 有弹框提示的页面刷新
    def page_refresh(self, switch_back: bool = False):
        """
        页面刷新
        :param switch_back: 刷新后是否切回最外层iframe
        """
        self.driver.refresh()
        alert = self.driver.switch_to.alert
        alert.accept()
        if switch_back:
            self.driver.switch_to.default_content()

    # 获取页面cookie，并按网站上传格式进行处理
    def get_cookies(self) -> str:
        """
        获取页面cookie，并按网站上传格式进行处理
        """
        return "; ".join([i["name"] + "=" + i["value"] for i in self.driver.get_cookies()])


# 读表方法
class ReadExcel:
    @staticmethod
    def init_data(excel_path, add_title: list, verify=None):
        """
        初始化读表，添加表头，支持检查表头，返回df
        :param excel_path: excel表路径
        :param add_title: 添加的表头，列表格式
        :param verify: 校验的表头，列表格式
        """
        if verify is None:
            verify = []
        df = pd.read_excel(excel_path, dtype=str)
        df.dropna(axis=0, how='all', subset=None, inplace=True)
        df.dropna(axis=1, how='all', subset=None, inplace=True)
        df.fillna("", inplace=True)
        for excel_title in add_title:
            if excel_title not in df.columns:
                df[excel_title] = ""
        for i in df.columns:
            df[i] = df[i].astype(str)
        try:
            df.to_excel(excel_path, index=False)
        except Exception as e:
            raise Exception("请关闭表格")
        ReadExcel.check_head(df, verify)
        return df

    @staticmethod
    def check_head(df, data: list):
        """
        表头校验
        :param df:
        :param data: 校验的表头，列表形式 []
        """
        head = list(set(data) - set(df.columns))
        assert not head, f"{head}表头不存在"

    @staticmethod
    def read_excels(excel_path):
        """
        适用于写入新表格，返回列表套字典
        :param excel_path: excel表路径
        """
        df = pd.read_excel(excel_path, dtype="string")
        duplicates = df.duplicated(keep=False)
        # 获取所有重复行的DataFrame
        duplicate_rows = df[duplicates]
        # 计算重复行的数量
        duplicate_count = duplicates.sum()
        if duplicate_count > 0:
            raise Exception(f"excel表中有重复行{duplicate_rows}，共计{duplicate_count}请人工核对！")
        lists = df.to_dict(orient='records')
        return lists, df

    @staticmethod
    def read_group_excel(excel_path):
        """
        添加表头，并按照excel表序号分组，最终返回[[{}, {}, {}], [{}, {}, {}], [{}., {}, {}]]格式
        :param excel_path: excel表路径
        """
        df = pd.read_excel(excel_path, sheet_name=0, header=0, dtype=str)
        for i in df.columns:
            df[i] = df[i].astype(str)
        log_info(df.columns)
        try:
            df.to_excel(excel_path, index=False)
        except Exception as e:
            raise Exception("请关闭表格")
        lists = [[] for i in range(len(df))]
        for index in df.index:
            dict_data = dict(df.iloc[index])
            lists[int(dict_data["序号"]) - 1].append(dict_data)
        filtered_list = [non_empty for non_empty in lists if non_empty]
        return filtered_list, df

    @staticmethod
    def wright_excel(result, save_path):
        """
        写入表格
        result: 必须为列表套列表格式  eg: [["案号", "结果"],["xxx", "成功"],["xxx", "成功"]]
        save_path: 写入excel的地址
        """
        df = pd.DataFrame(result[1:], columns=result[0])
        df.to_excel(save_path, index=False)

    @staticmethod
    # 列表套字典格式 写入excel
    def dict_to_excel(data, save_path):
        """
        列表套字典格式 写入excel
        :param data: 必须为列表套字典格式  eg: [{}, {}, {}]
        :param save_path: 写入excel的地址
        """
        df = pd.DataFrame(data, dtype=str)
        df.to_excel(save_path, index=False)


# 数据库方法
class DataBase:
    def __init__(self, host, user, password, db) -> None:
        """
        建立数据表连接
        :param host: 主机地址
        :param user: 用户名
        :param password: 密码
        :param db: 数据表
        """
        self.conn = pymysql.connect(
            host=host,
            user=user,
            password=password,
            db=db,
            charset='utf8'
        )
        self.cursor = self.conn.cursor()

    def query(self, sql) -> tuple:
        """
        查询
        :param sql: sql语句
        """
        # 执行SQL
        self.cursor.execute(sql)
        # 提交事务
        result = self.cursor.fetchall()
        return result

    def execute(self, sql):
        """
        增、删、改
        :param sql: sql语句
        """
        try:
            # 执行SQL
            self.cursor.execute(sql)
            # 提交事务
            self.conn.commit()
        except Exception as e:
            # 报错，回滚事务
            print(e)
            if self.conn:
                self.conn.rollback()

    def close(self) -> None:
        """
        关闭链接与游标
        """
        self.cursor.close()
        self.conn.close()


# 其他方法
class OtherFunction:
    # 图片识别并点击
    @staticmethod
    def img_click(img_path, is_double_click: bool = False, max_time: int = 30):
        """
        图片点击
        :param max_time: 找寻图片的最大等待时长
        :param img_path: 需要点击的图片保存的位置
        :param is_double_click: False表示单击，True表示双击
        :return:
        """
        # 加载图片和模板
        image = cv.imread(img_path, cv.IMREAD_COLOR)
        _path = f"c:/Users/{os.getlogin()}/.WindowsImg"
        if not os.path.exists(_path):
            try:
                os.makedirs(_path)  # 递归创建目录 因为有些没有用户目录 导致创建报错
            except Exception as e:
                raise Exception(f"当前用户无权限 创建{_path} 请手动创建")
        img_path_name = _path + "/" + str(time.time()).replace(".", "_") + ".png"
        screenshot = ImageGrab.grab()
        screenshot.save(img_path_name)
        matcher_mode = cv.TM_CCOEFF_NORMED
        time.sleep(1)
        template = cv.imread(img_path_name, cv.IMREAD_COLOR)
        all_time = time.time() + max_time
        while time.time() <= all_time:
            try:
                result = cv.matchTemplate(template, image, matcher_mode)
                # 找到最佳匹配位置
                _, max_val, _, max_loc = cv.minMaxLoc(result)
                # 获取匹配区域的坐标
                x, y = max_loc
                w, h, s = image.shape[1], image.shape[0], image.shape[2]  # 宽度在索引1，高度在索引0
                # 打印匹配区域的坐标
                log_info(f"匹配区域坐标：({x}, {y})，宽高：({w}, {h})")
                # 使用 win32api 移动鼠标到匹配区域
                time.sleep(2)
                win32api.SetCursorPos((int(x + w / 2), int(y + h / 2)))  # 设置鼠标位置到图片中心点
                if is_double_click is False:
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0)  # 鼠标左键按下
                    time.sleep(0.1)  # 等待0.1秒
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0)
                else:
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0)  # 鼠标左键按下
                    time.sleep(0.1)  # 等待0.1秒
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0)
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0)  # 鼠标左键按下
                    time.sleep(0.1)  # 等待0.1秒
                    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0)
                os.remove(img_path_name)
                return True
            except Exception as e:
                print(e)
                if os.path.exists(img_path_name):
                    os.remove(img_path_name)
                    continue
        raise Exception("寻找图片超时，请检查分辨率或图片地址是否正确！！！")

    # 控制下载页面执行下载操作selenium版
    @staticmethod
    def chrome_down_path(file_path):
        """
        在谷歌浏览器下，点击下载会弹出下载保存位置的弹窗，不适用移动文件，直接输入要存储的路径，文件就会保存在file_path位置了。
        注意：1.使用之前，谷歌浏览器的下载弹窗要显示出来
             2.如果文件路径已经存在，会又有一个弹窗，这里没做判断，写代码自己判断下文件路径是否存在
        :param file_path: 文件保存位置
        """
        time.sleep(2)
        no1 = win32gui.FindWindow("#32770", "另存为")  # 一级窗口
        button = win32gui.FindWindowEx(no1, 0, "Button", "打开(&O)")
        a1 = win32gui.FindWindowEx(no1, 0, "DUIViewWndClassName", None)
        a2 = win32gui.FindWindowEx(a1, 0, "DirectUIHWND", None)
        a3 = win32gui.FindWindowEx(a2, 0, "FloatNotifySink", None)
        a4 = win32gui.FindWindowEx(a3, 0, "ComboBox", None)
        edit = win32gui.FindWindowEx(a4, None, "Edit", None)
        win32gui.SendMessage(edit, win32con.WM_SETTEXT, None, file_path)
        win32gui.SendMessage(no1, win32con.WM_COMMAND, 1, button)

    # 模糊匹配查找文件或文件夹
    @staticmethod
    def find_file(directory: str, key: str, strict_match: bool = False, strict_error: bool = False):
        """
        根据key 匹配查找文件夹下的某个文件夹或文件，不支持深度查找
        :param directory: 文件夹位置
        :param key: 匹配关键字
        :param strict_match: 是否精确匹配
        :param strict_error: 文件未匹配到是否报错
        """
        if strict_match:
            file_list = [os.path.join(directory, file) for file in os.listdir(directory) if key == file]
        else:
            file_list = [os.path.join(directory, file) for file in os.listdir(directory) if key in file]

        if strict_error and len(file_list) == 0:
            raise FileNotFoundError(f'{os.path.join(directory, key)}：文件不存在')
        return file_list

    # 判断文件是否存在
    @staticmethod
    def exist_file(file_path):
        """
        判断文件是否存在
        :param file_path: 文件路径
        """
        assert os.path.exists(file_path), f"{file_path}: 文件不存在"

    # 小重试方法
    @staticmethod
    def unit_testing(f):
        def decorated(*args, **kwargs):
            retry = kwargs.pop('retry') if kwargs.get('retry', None) else 4
            fun = kwargs.pop('fun') if kwargs.get('fun', None) else None
            for i in range(retry):
                try:
                    res = f(*args, **kwargs)
                    return res
                except Exception as e:
                    log_info(e)
                    if i >= retry - 1:
                        raise Exception(e)
                    if fun is not None:
                        fun()
                log_info(f"异常调试{i + 1}")

        return decorated

    # 大重试方法
    @staticmethod
    def big_retry(pre_func, retries=3, delay=1):
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                for i in range(retries):
                    try:
                        pre_func()
                        return func(*args, **kwargs)
                    except Exception as e:
                        if i == retries - 1:
                            raise e
                        time.sleep(delay)

            return wrapper

        return decorator

    # 关闭windows的上传文件对话框
    @staticmethod
    def close_dialog_box(title):
        """
        关闭windows的上传文件对话框
        :param title: 对话框打开时的标题
        """
        # title = "打开"
        hwnd = win32gui.FindWindow(None, title)
        win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)

    # 循环遍历输出文件夹下所有文件路径
    @staticmethod
    def get_file_path(directory):
        """
        获取文件夹下所有文件的路径，存储到字符串，用\n进行分割
        :param directory: 文件位置
        """
        files = '\n'.join([os.path.join(root, file) for root, dirs, files in os.walk(directory) for file in files])
        return files

    # 根据身份证信息返回性别和年龄
    @staticmethod
    def cid_information(cid: str):
        """
        根据身份证信息返回性别和年龄
        :param cid: 中国身份证号码
        """
        if len(cid) != 18:
            raise ValueError("身份证号码应为18位")
        # 解析出生日期
        birth_date = cid[6:14]
        year = birth_date[:4]
        month = birth_date[4:6]
        day = birth_date[6:]
        # 解析性别
        gender_digit = int(cid[16])
        gender = "男" if gender_digit % 2 == 1 else "女"

        return {
            "性别": gender,
            "出生日期": f"{year}-{month}-{day}"
        }

    # 程序报错截图
    @staticmethod
    def error_img(program_name: str, identification: str = None):
        """
        程序报错截图
        :param program_name:程序名称
        :param identification: 标识，用于添加使用该方法时可能需要的标识，方便查找
        """
        _path = f"c:/Users/{os.getlogin()}/.ErrorImage"
        if not os.path.exists(_path):
            try:
                os.makedirs(_path)  # 递归创建目录 因为有些没有用户目录 导致创建报错
            except Exception as e:
                raise Exception(f"当前用户无权限 创建{_path} 请手动创建")
        if identification is not None:
            img_path_name = _path + "/" + str(time.time()).replace(".", "_") + program_name + identification + ".png"
            screenshot = ImageGrab.grab()
            screenshot.save(img_path_name)
            log_error(f"截图保存再: {img_path_name}")
            return
        img_path_name = _path + "/" + str(time.time()).replace(".", "_") + program_name + ".png"
        screenshot = ImageGrab.grab()
        screenshot.save(img_path_name)
        log_error(f"截图保存再: {img_path_name}")

    # 将指定数据复制到剪切板
    @staticmethod
    def win32_copy(copy_data):
        """
        将指定数据复制到剪切板
        :param copy_data: 需要复制的数据
        """
        clipboard.OpenClipboard()
        # 清空剪切板
        clipboard.EmptyClipboard()
        # 设置剪切板数据
        clipboard.SetClipboardData(win32con.CF_UNICODETEXT, copy_data)
        # 关闭剪切板
        clipboard.CloseClipboard()

    # 执行粘贴操作
    @staticmethod
    def win32_stick():
        """
         执行粘贴操作
        """
        # 按下 Ctrl 键
        win32api.keybd_event(win32con.VK_CONTROL, 0, 0, 0)
        # 按下 V 键
        win32api.keybd_event(ord('V'), 0, 0, 0)
        # 释放 V 键
        win32api.keybd_event(ord('V'), 0, win32con.KEYEVENTF_KEYUP, 0)
        # 释放 Ctrl 键
        win32api.keybd_event(win32con.VK_CONTROL, 0, win32con.KEYEVENTF_KEYUP, 0)


# 创建tk登录页面
class TkFunction:
    def __init__(self, cx_name, need_paper_path: list, login_type: int = 1):
        self.cx_name = cx_name  # 程序名称
        self.need_paper_path = need_paper_path  # 用户输入的选择文件夹名称
        self.login_type = login_type  # 分辨手动登录还是自动登录
        self.content_data = {}  # 记录用户输入的账号密码及选择的文件路径
        self.index = 0

    # 添加账号方法
    def zh_fun(self, root):
        # 创建两个密码输入框
        label1 = tk.Label(root, text="请输入账号：")
        self.font_ground(label1)
        entry1 = tk.Entry(root)  # 第一个密码输入框
        self.enter_ground(entry1)
        las1 = tk.Label(root, text=" ")
        label2 = tk.Label(root, text="请输入密码：")
        self.font_ground(label2)
        entry2 = tk.Entry(root, show="*")  # 第二个密码输入框
        self.enter_ground(entry2)
        las2 = tk.Label(root, text=" ")
        # 添加到布局
        label1.pack()
        entry1.pack()
        las1.pack()
        label2.pack()
        entry2.pack()
        las2.pack()
        return entry1, entry2

    # 记录输入的账号密码，写入字典
    def handle_input(self, entry1, entry2, root):
        username = entry1.get()
        password = entry2.get()
        self.content_data["账号"] = username
        self.content_data["密码"] = password
        # 关闭窗口
        root.destroy()

    # 点选方法提交
    def handle_input2(self, root):
        self.xz_name = self.selected_value.get()
        for group in self.gr_list:
            item = group.iloc[0]
            if item["程序名称"] == self.xz_name:
                self.content_data["账号"] = item["用户名"]
                self.content_data["密码"] = item["密码"]
                break
        root.destroy()

    # 创建一个文件选择对话框
    def select_file(self, root, index, paper_entry):
        filename = filedialog.askdirectory()
        if filename:
            paper_entry.delete(0, tk.END)  # 清空输入框内容
            paper_entry.insert(0, filename)
            self.content_data[index] = filename
        if self.index+1 < len(self.need_paper_path):
            self.index += 1

    # 创建一个文件选择对话框
    def excel_file(self, parent, folder_entry):
        filename = filedialog.askopenfilename(
            parent=parent,  # 指定父窗口
            filetypes=[("Excel 文件", "*.xlsx *.xls")],
            title="选择文件"
        )
        if filename:
            folder_entry.delete(0, tk.END)  # 清空输入框内容
            folder_entry.insert(0, filename)
        self.content_data["excel地址"] = filename

    # 设置输入框样式
    def enter_ground(self, enter):
        enter.config(
            font=("Arial", 14, "bold"),  # 设置字体样式
            borderwidth=2,  # 设置边框宽度
            relief="sunken",  # 设置边框的凹陷效果
            bg="white",  # 设置背景颜色
            fg="black",  # 设置文本颜色
            selectbackground="blue",  # 设置选中文本的背景颜色
            selectforeground="white"  # 设置选中文本的文本颜色
        )

    # 设置按钮样式
    def button_ground(self, button):
        button.config(
            font=("Arial", 14, "bold"),  # 设置字体样式
            borderwidth=2,  # 设置边框宽度
            relief="groove",  # 设置边框的凹陷效果
            bg="lightgrey",  # 设置背景颜色
            fg="black",  # 设置文本颜色
            highlightbackground="red",  # 设置鼠标悬停时的背景颜色
            highlightcolor="black",  # 设置鼠标悬停时的文本颜色
        )

    # 设置字体样式
    def font_ground(self, font):
        font.config(
            font=("Arial", 14, "bold")  # 设置字体大小和颜色
        )

    # 主函数
    def tk_fun(self):
        # 创建tk窗口
        root = tk.Tk()
        # 设置tk窗口的标题
        root.title(self.cx_name)
        # 设置窗口大小
        if len(self.need_paper_path) < 1:
            root.geometry("400x450")
        else:
            height = (len(self.need_paper_path) + 1) * 200
            root.geometry(f"400x{height}")
        # 输入1显示输入账号密码其他则是从指定excel表中获取数据
        if self.login_type == 1:
            entry1, entry2 = self.zh_fun(root)
        else:
            # 创建提示
            label1 = tk.Label(root, text="请选择账号：")
            # 设置样式
            self.font_ground(label1)
            # 展示
            label1.pack()
            df = pd.read_excel(r"C:\rpa\账号.xlsx", dtype=str)
            self.gr_list = [df[i:i + 1] for i in range(0, len(df), 1)]
            self.name_data = []
            for i in self.gr_list:
                self.name_data += (i.iloc[0]["程序名称"],)
            # 创建一个下拉框
            self.selected_value = tk.StringVar()
            combo_box = ttk.Combobox(root, textvariable=self.selected_value)
            # 给下拉框添加选项（self.name_data:读表中的名称，并将名称按元组格式统一记录）
            combo_box['values'] = self.name_data
            combo_box.pack()
            # 设置默认显示值
            combo_box.current(0)
            # combo_box.bind('<<ComboboxSelected>>', self.print_selected_value)

        # 显示excel选择的输入框
        label0 = tk.Label(root, text="请选择excel表格")
        self.font_ground(label0)
        label0.pack()
        folder_entry = tk.Entry(root)
        self.enter_ground(folder_entry)
        folder_entry.pack()
        browse_button0 = tk.Button(root, text="选择文件", command=lambda: self.excel_file(root, folder_entry))
        self.button_ground(browse_button0)
        las0 = tk.Label(root, text=" ")
        browse_button0.pack()
        las0.pack()

        # 选择文件夹的，如果传参列表为空则不展示选择文件的输入框
        if len(self.need_paper_path) > 0:
            self.name_data = {}
            num = 3
            for index, value_name in enumerate(self.need_paper_path):
                num += index
                self.name_data["label"+str(num)] = tk.Label(root, text=f"请选择{value_name}所在位置")
                self.font_ground(self.name_data["label"+str(num)])
                self.name_data[value_name] = tk.Entry(root)
                self.enter_ground(self.name_data[value_name])

                print(self.need_paper_path)
                print(index)
                self.name_data[value_name + str(num)] = tk.Button(root, text="选择文件",
                                          command=lambda: self.select_file(root, self.need_paper_path[self.index], self.name_data[self.need_paper_path[self.index]]))

                self.button_ground(self.name_data[value_name + str(num)])
                self.name_data["las"+str(num)] = tk.Label(root, text=" ")
                self.name_data["label"+str(num)].pack()
                self.name_data[value_name].pack()
                self.name_data[value_name + str(num)].pack()
                self.name_data["las"+str(num)].pack()
        # 提交方法
        if self.login_type == 1:
            submit_button = tk.Button(root, text="提交", command=lambda: self.handle_input(entry1, entry2, root))

        else:
            submit_button = tk.Button(root, text="提交", command=lambda: self.handle_input2(root))
            try:
                print(self.content_data["账号"])
            except:
                self.content_data["账号"] = self.gr_list[0].iloc[0]["用户名"]
                self.content_data["密码"] = self.gr_list[0].iloc[0]["密码"]
        self.button_ground(submit_button)
        submit_button.pack()
        root.mainloop()
        return self.content_data


# playwright方法
class PlayPage(object):
    def __init__(self, **kwargs):
        js = """
                Object.defineProperties(navigator,{webdriver:{get:()=>undefined}});
            """
        self.p = sync_playwright().start()
        self.browser = self.p.chromium.launch(headless=False,
                                              executable_path=kwargs.get("exec_path"),
                                              args=[
                                                  ""
                                                  "--disable-features=SameSiteByDefaultCookies, "
                                                  "CookiesWithoutSameSiteMustBeSecure"
                                                  "--start-maximized"
                                              ])
        if kwargs.get("session"):
            context = self.browser.new_context(storage_state=kwargs.get("session"), no_viewport=True)
        else:
            context = self.browser.new_context(no_viewport=True)
        context.add_init_script(js)
        self.context = context
        self.page = self.context.new_page()

    # playwright关闭其他页面
    def close_other_label(self, page):
        """
        playwright关闭其他页面
        """
        for i in self.context.pages:
            if i.title() == page:
                continue
            i.close()
        time.sleep(1)

    # playwright滑块一次滑到低
    def playwright_slider_verification(self, page, hk_xpath):
        """
        playwright滑块一次滑到低
        :param page:
        :param hk_xpath: 滑块的xpath
        """
        # 获取滑块的元素句柄
        slider = page.query_selector(hk_xpath)
        # 获取滑块的位置
        slider_box = slider.bounding_box()
        # 如果滑块有固定的移动轨迹，则可能需要计算移动距离
        # 否则，可以直接指定移动的坐标
        move_x = 1000  # 水平移动的距离
        move_y = 0  # 垂直移动的距离，通常为0
        # 模拟拖动滑块
        page.mouse.move(slider_box['x'] + slider_box['width'] / 2, slider_box['y'] + slider_box['height'] / 2)
        page.mouse.down()
        page.mouse.move(slider_box['x'] + slider_box['width'] / 2 + move_x,
                        slider_box['y'] + slider_box['height'] / 2 + move_y)
        page.mouse.up()

    # playwright截图并保存
    def playwright_screenshot(self, page, xpath, photo_name, screenshot_is_all=False):
        """
        playwright截图并保存
        :param page:
        :param xpath:
        :param photo_name: 保存文件的路径
        :param screenshot_is_all: 是否截取全屏默认按元素截取
        """
        if screenshot_is_all:
            page.screenshot(path=photo_name)
            log_info(f"图片保存在{photo_name}")
            return
        content_element = page.locator(xpath)
        if content_element:
            # 获取元素的边界，以便确定截图区域
            bounding_box = content_element.bounding_box()
            if bounding_box:
                page.screenshot(path=photo_name, clip=bounding_box)
                log_info(f"图片保存在{photo_name}")
                return

    # playwright1.15.3没有连续切入iframe方法，自己封装
    def playwright_frame(self, page, xpath: list):
        frame = None
        for i in xpath:
            frame = page.query_selector(i).content_frame()
        return frame


# 加解密
class EncodeDecrypt:
    # AES加解密
    @staticmethod
    def aes_encrypt_decrypt(text, key, is_foll=False):
        """
        :param text:加密的文本
        :param key:密钥
        :param is_foll:加密还是解密，默认False加密
        """

        def to_16(key):
            """
            转为16倍数的bytes数据
            :param key:
            :return:
            """
            if len(key) > 32:
                keys = key[:32]
            else:
                keys = key
            keyes = bytes(keys, encoding="utf8")
            while len(keyes) % 16 != 0:
                keyes += b'\0'
            return keyes  # 返回bytes

        aes = AES.new(to_16(key), AES.MODE_ECB)  # 初始化加密器
        if is_foll is False:
            return str(base64.encodebytes(aes.encrypt(to_16(text))), encoding='utf8').replace('\n', '')  # 加密
        return str(aes.decrypt(base64.decodebytes(bytes(text, encoding='utf8'))).rstrip(b'\0').decode("utf8"))  # 解密

    # RSA 加解密
    @staticmethod
    def rsa_encrypt_decrypt(message, pubkey=None, private_key=None, number=2048):
        """
        :param message:要加密的文本
        :param pubkey: 公钥
        :param private_key: 私钥
        :param number: 加密长度
        """
        if pubkey is None or private_key is None:
            pubkey, private_key = rsa.newkeys(number)

        if isinstance(message, str):
            content = message.encode('utf-8')
            crypto = rsa.encrypt(content, pubkey)
            return crypto, pubkey, private_key
        else:
            try:
                content = rsa.decrypt(message, private_key)
                con = content.decode('utf-8')
                return con
            except rsa.DecryptionError as e:
                print(f"解密失败: {e}")
                return None

    # DES 加密
    @staticmethod
    def des_encrypt_decrypt(plaintext, key=None, iv=None):
        """
        :param plaintext: 加密文本
        :param key:
        :param iv:
        """
        if key is not None and iv is not None:
            if not isinstance(key, bytes):
                key = bytes(key, encoding="utf8")
            if not isinstance(iv, bytes):
                iv = bytes(iv, encoding="utf8")
        else:
            # 随机生成一个8字节（64位）的密钥
            key = token_bytes(8)
            iv = token_bytes(8)

        if isinstance(plaintext, str):
            if not isinstance(plaintext, bytes):
                plaintext = bytes(plaintext, "utf-8")
            secret_key = key
            iv = iv
            k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)
            en = k.encrypt(plaintext, padmode=PAD_PKCS5)
            return en
        secret_key = key
        iv = iv
        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)
        de = k.decrypt(plaintext, padmode=PAD_PKCS5)
        return de.decode()

    # DES3加解密
    @staticmethod
    def des3_encrypt_decrypt(data, key=None, is_fell=False):
        def generate_des3_key():
            while True:
                key = token_bytes(24)
                if DES3.adjust_key_parity(key):
                    return key
        if key is None:
            key = generate_des3_key()
        else:
            key = key
        mode = DES3.MODE_ECB
        if is_fell is False:
            if not isinstance(data, bytes):
                data = bytes(data, 'utf-8')
            x = len(data) % 8
            data = data + b'\0' * x
            cryptor = DES3.new(key, mode)
            ciphertext = cryptor.encrypt(data)
            return ciphertext
        cryptor = DES3.new(key, mode)
        plain_text = cryptor.decrypt(data)
        st = str(plain_text.decode("utf-8")).rstrip('\0')
        return st

    # md5加密
    @staticmethod
    def use_md5(test):
        if not isinstance(test, bytes):
            test = bytes(test, 'utf-8')
        m = hashlib.md5()
        m.update(test)
        return m.hexdigest()

    # hmac加密
    @staticmethod
    def use_hmac(key, text):
        if not isinstance(key, bytes):
            key = bytes(key, 'utf-8')
        if not isinstance(text, bytes):
            text = bytes(text, 'utf-8')
        h = hmac.new(key, text, digestmod='MD5')
        return h.hexdigest()

    # SHA加密
    @staticmethod
    def use_sha(text):
        if not isinstance(text, bytes):
            text = bytes(text, 'utf-8')
        sha = hashlib.sha1(text)
        encrypts = sha.hexdigest()
        return encrypts

    # urllib解码
    @staticmethod
    def encode_dict_values(data, encode: bool = True):
        """
        :param data: 要加解密的字符串（大部分时间是url，但是不排除有些网站上传材料也用这个）
        :param encode: 进行加密操作还是解密操作，默认加密
        """
        if encode:
            decoded_query = urllib.parse.unquote(data)
            return decoded_query
        if isinstance(data, dict):
            encoded_dict = {}
            for key, value in data.items():
                encoded_value = EncodeDecrypt.encode_dict_values(value)  # 递归调用
                encoded_dict[key] = encoded_value
            return encoded_dict
        elif isinstance(data, str):
            return urllib.parse.quote(data.replace('%', '\\').encode('utf-8').decode('unicode_escape'))
        else:
            return data

    # sm2加解密方法
    @staticmethod
    def sm2_encode(enciphered_data: str, public_key=None, private_key=None):
        """
        sm2加解密方法
        :param enciphered_data: 加密数据
        :param public_key: 公钥
        :param private_key: 私钥

        """
        data_bytes = enciphered_data.encode('utf-8')
        if private_key is None or private_key is None:
            # 生成公钥和私钥
            def generate_sm2_keypair():
                """
                sm2加密的生成公私钥方法
                """
                private_key = secrets.token_hex(32)  # 生成32字节的私钥
                sm2_crypt = sm2.CryptSM2(public_key='', private_key=private_key)
                public_key = sm2_crypt._kg(int(private_key, 16), sm2.default_ecc_table['g'])
                return public_key, private_key

            public_key, private_key = generate_sm2_keypair()
        sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)
        # 加密
        enc_data1 = sm2_crypt.encrypt(data_bytes)
        enc_data = enc_data1.hex()

        # 解密
        dec_data = sm2_crypt.decrypt(enc_data1)
        dec_data = dec_data.decode()
        return enc_data, dec_data

    # sm3转哈希值
    @staticmethod
    def sm3_encode(enciphered_data):
        """
        sm3转哈希值
        :param enciphered_data: 需要转哈希的值
        """
        data_bytes = enciphered_data.encode('utf-8')  # 将字符串编码为字节
        # 生成SM3哈希值
        sm3_result = sm3.sm3_hash(func.bytes_to_list(data_bytes))
        return sm3_result

    # sm4两种加解密方式
    @staticmethod
    def sm4_encode(enciphered_data, secret_key, mode: int = 1, secret_iv=None):
        """
        sm4两种加解密方式:  CBC（加密块链模式）和 ECB模式（电子密码本模式）
        :param enciphered_data: 需要加密的值
        :param secret_key: sm4密钥
        :param mode: 选择的模式（1为ECB模式，其它为CBC模式）
        :param secret_iv: sm4的iv值（CBC模式才用到）
        """
        data_bytes = enciphered_data.encode('utf-8')
        if mode != 1:
            padding_length = 16 - len(data_bytes) % 16
            data_bytes += bytes([padding_length] * padding_length)
        # 创建SM4对象
        sm4_crypt = sm4.CryptSM4()
        if mode == 1:
            # 设置密钥
            sm4_crypt.set_key(secret_key, sm4.SM4_ENCRYPT)
            # 加密
            enc_data = sm4_crypt.crypt_ecb(data_bytes)
            enc_data1 = enc_data.hex()
            # 解密
            sm4_crypt.set_key(secret_key, sm4.SM4_DECRYPT)
            dec_data = sm4_crypt.crypt_ecb(enc_data)
            dec_data = dec_data.decode('utf-8')
            return enc_data1, dec_data
        # 设置密钥和IV用于加密
        sm4_crypt.set_key(secret_key, sm4.SM4_ENCRYPT)
        # 加密
        enc_data = sm4_crypt.crypt_cbc(secret_iv, data_bytes)
        enc_data1 = enc_data.hex()
        # 设置密钥和IV用于解密
        sm4_crypt.set_key(secret_key, sm4.SM4_DECRYPT)
        dec_data = sm4_crypt.crypt_cbc(secret_iv, enc_data)
        # 去除填充
        padding_length = dec_data[-1]
        dec_data = dec_data[:-padding_length]
        dec_data = dec_data.decode('utf-8')
        return enc_data1, dec_data


#     # data_information = TkFunction(cx_name="律师平台立案提交", need_paper_path=["保全", "律师"], login_type=0).tk_fun()
#     # print(data_information)
#     """AES加密"""
#     # 密钥
#     # key = "assssssssdfasasasasa"
#     # aes_test = UseAES(key)
#     # a = aes_test.encrypt("测试")
#     # b = aes_test.decode_bytes(a)
#     # print(a)
#     # print(b)
#     """RSA加密"""
#     # context = "加密内容"
#     # rsa_test = UseRSA()
#     # a = rsa_test.rsa_encrypt(context)
#     # b = rsa_test.rsa_decrypt(a)
#     # print(a)
#     # print(b)
#     """DES加密"""
#     # des_test = UseDES(b"12345678", b"12345678")
#     # des_test = UseDES()
#     # a = des_test.encrypt("测试加密")
#     # b = des_test.descrypt(a)
#     # print(a)
#     # print(b)
#     """DES3加密"""
#     # des3_test = UseDES3(b"123456789qazxswe")
#     # des3_test = UseDES3()
#     # a = des3_test.encrypt("测试加密")
#     # b = des3_test.decrypt(a)
#     # print(a)
#     # print(b)
#     """MD5, hmac, sha加密"""
#     # md5_test = use_md5("测试签名")
#     # hmac_test = use_hmac("123456", "测试")
#     # sha_test = use_sha("测试加密")
#     # print(md5_test)
#     # print(hmac_test)
#     # print(sha_test)
#     """ urllib解码 """
#     # data = 'https%3A%2F%2Fexample.com%2Fpath%3Fquery%3Dpython%26name%3D%E4%BE%AF%E9%94%90'
#     # cs = encode_dict_values(data, encode=True)
#     # print(cs)
#     # page = PlayPage(exec_path=os.environ["chrome"], session=None).page
#     # page.goto('https://baoquan.court.gov.cn/#/home/index')
#     # print(1)
#     """ sm2加解密 """
#     # sm2_data = "Hello, SM2!"
#     # # private_key = '00BE9EDB7C1D1DB0E4C9B5D49963C74D5B5AC4312587DC8F3EC8C5E5DA55A56B'
#     # # public_key = '04B0E8B6E3B3688993ADAD0F3B95A5AD0E15A5D9D1263D4FCA9D4A3B2487DA2F8FA67E7E7DC0D4264F8C2E77F8F3B3B7E681507B0F191DB96D247ECC52D7C08CB9'
#     # sm2_enc_result, sm2_dic_result = sm2_encode(sm2_data)
#     # print(sm2_enc_result, sm2_dic_result)
#     """ sm3加解密 """
#     # sm3_data = "Hello, SM3!"
#     # sm3_result = sm3_encode(sm3_data)
#     # print(sm3_result)
#     """ sm4加解密 """
#     " ECB模式（电子密码本模式）"
#     # key = b'0123456789abcdef'
#     # data = "你好世界！"
#     # sm4_enc_result, sm4_dic_result = sm4_encode(secret_key=key, enciphered_data=data)
#     # print(sm4_enc_result)
#     # print(sm4_dic_result)
#     " CBC（加密块链模式）"
#     # SM4密钥（16字节）
#     key = b'0123456789abcdef'
#     # SM4 IV（16字节）
#     iv = b'1234567890abcdef'
#     data = "你好世界！"
#     sm4_enc_result, sm4_dic_result = sm4_encode(secret_key=key, enciphered_data=data, secret_iv=iv, mode=2)
#     print(sm4_enc_result)
#     print(sm4_dic_result)



